<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lux: src/parser/parser.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lux<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">A low-level compiled alternative to C, C++, and more!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_6cd8491d143eb218b70983dbdb3c58bc.html">parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">parser.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implementation of the parser module for the programming language compiler.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdalign.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ast_8h_source.html">../ast/ast.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="error_8h_source.html">../c_libs/error/error.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memory_8h_source.html">../c_libs/memory/memory.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="parser_8h_source.html">parser.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for parser.c:</div>
<div class="dyncontent">
<div class="center"><img src="parser_8c__incl.png" border="0" usemap="#asrc_2parser_2parser_8c" alt=""/></div>
<map name="asrc_2parser_2parser_8c" id="asrc_2parser_2parser_8c">
<area shape="rect" title="Implementation of the parser module for the programming language compiler." alt="" coords="157,5,298,31"/>
<area shape="rect" title=" " alt="" coords="5,299,92,324"/>
<area shape="poly" title=" " alt="" coords="157,33,113,50,93,63,76,80,61,104,51,131,41,188,41,242,46,285,41,285,36,242,36,187,46,130,56,102,72,77,89,59,110,45,155,28"/>
<area shape="rect" title=" " alt="" coords="86,79,153,104"/>
<area shape="poly" title=" " alt="" coords="211,33,150,73,147,69,209,28"/>
<area shape="rect" href="ast_8h.html" title=" " alt="" coords="159,152,250,177"/>
<area shape="poly" title=" " alt="" coords="227,32,218,79,210,139,205,138,213,78,222,31"/>
<area shape="rect" href="memory_8h.html" title="Arena allocator and growable array utilities for fast memory management." alt="" coords="241,225,440,251"/>
<area shape="poly" title=" " alt="" coords="256,28,288,48,316,77,332,111,341,148,345,212,340,212,336,149,327,113,312,80,285,52,253,33"/>
<area shape="rect" href="error_8h.html" title="Error reporting utilities for lexer and parser diagnostics." alt="" coords="419,79,571,104"/>
<area shape="poly" title=" " alt="" coords="271,28,440,73,438,78,270,33"/>
<area shape="rect" href="parser_8h.html" title="Recursive descent and Pratt parser for the Zura language." alt="" coords="227,79,302,104"/>
<area shape="poly" title=" " alt="" coords="236,30,255,65,250,68,231,32"/>
<area shape="rect" title=" " alt="" coords="299,299,382,324"/>
<area shape="poly" title=" " alt="" coords="208,177,214,212,221,231,232,249,260,274,293,291,290,296,257,278,228,252,217,234,209,213,203,178"/>
<area shape="rect" title=" " alt="" coords="117,299,191,324"/>
<area shape="poly" title=" " alt="" coords="203,179,165,287,160,285,198,177"/>
<area shape="poly" title=" " alt="" coords="228,175,308,217,305,221,225,180"/>
<area shape="poly" title=" " alt="" coords="294,253,106,299,104,294,293,248"/>
<area shape="poly" title=" " alt="" coords="343,251,343,285,338,285,338,251"/>
<area shape="poly" title=" " alt="" coords="312,253,198,296,196,291,310,248"/>
<area shape="poly" title=" " alt="" coords="508,103,529,131,551,169,558,190,562,212,559,233,549,252,525,270,486,284,396,304,395,299,484,279,522,265,545,249,554,231,556,212,553,192,546,171,525,134,504,106"/>
<area shape="poly" title=" " alt="" coords="506,103,521,138,523,159,516,179,488,206,452,223,450,219,485,202,512,176,518,159,516,140,501,105"/>
<area shape="rect" href="lexer_8h.html" title="Tokenizer (lexer) definitions and API for lexical analysis of source code." alt="" coords="377,152,502,177"/>
<area shape="poly" title=" " alt="" coords="488,106,459,143,455,140,484,103"/>
<area shape="poly" title=" " alt="" coords="425,180,369,219,366,215,422,175"/>
<area shape="rect" title=" " alt="" coords="464,225,535,251"/>
<area shape="poly" title=" " alt="" coords="451,176,483,213,479,217,447,179"/>
<area shape="poly" title=" " alt="" coords="257,106,225,143,221,140,253,103"/>
<area shape="poly" title=" " alt="" coords="228,103,185,121,165,135,150,153,137,186,135,222,140,256,148,285,143,287,135,257,130,222,132,185,145,151,161,131,182,117,226,98"/>
<area shape="poly" title=" " alt="" coords="273,103,331,212,326,215,269,106"/>
<area shape="poly" title=" " alt="" coords="294,102,399,144,397,149,292,106"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9a2a8ba5bea0c6ee41058bf6f8eb6178" id="r_a9a2a8ba5bea0c6ee41058bf6f8eb6178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#a9a2a8ba5bea0c6ee41058bf6f8eb6178">parser_error</a> (<a class="el" href="structParser.html">Parser</a> *psr, const char *error_type, const char *file, const char *msg, int line, int col, int tk_length)</td></tr>
<tr class="memdesc:a9a2a8ba5bea0c6ee41058bf6f8eb6178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports a parser error with detailed location information.  <br /></td></tr>
<tr class="separator:a9a2a8ba5bea0c6ee41058bf6f8eb6178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a3429a7335866e6d3e6da546e7dbab" id="r_a92a3429a7335866e6d3e6da546e7dbab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#a92a3429a7335866e6d3e6da546e7dbab">parse</a> (<a class="el" href="structGrowableArray.html">GrowableArray</a> *tks, <a class="el" href="structArenaAllocator.html">ArenaAllocator</a> *arena)</td></tr>
<tr class="memdesc:a92a3429a7335866e6d3e6da546e7dbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main parsing function that converts tokens into an AST.  <br /></td></tr>
<tr class="separator:a92a3429a7335866e6d3e6da546e7dbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd32c60384ae40c357cc28e65fd764d1" id="r_abd32c60384ae40c357cc28e65fd764d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#abd32c60384ae40c357cc28e65fd764d1">get_bp</a> (<a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921">TokenType</a> kind)</td></tr>
<tr class="memdesc:abd32c60384ae40c357cc28e65fd764d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the binding power (precedence) for a given token type.  <br /></td></tr>
<tr class="separator:abd32c60384ae40c357cc28e65fd764d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ffb04f9526d5ee88fa488db078cbc1" id="r_a39ffb04f9526d5ee88fa488db078cbc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#a39ffb04f9526d5ee88fa488db078cbc1">nud</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a39ffb04f9526d5ee88fa488db078cbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null Denotation - handles prefix expressions and primary expressions.  <br /></td></tr>
<tr class="separator:a39ffb04f9526d5ee88fa488db078cbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad715ebb051a669c00dc55cdcd31bed2d" id="r_ad715ebb051a669c00dc55cdcd31bed2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#ad715ebb051a669c00dc55cdcd31bed2d">led</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="memdesc:ad715ebb051a669c00dc55cdcd31bed2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left Denotation - handles binary and postfix expressions.  <br /></td></tr>
<tr class="separator:ad715ebb051a669c00dc55cdcd31bed2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2701baa126589d22ff03eb7ebbada5f5" id="r_a2701baa126589d22ff03eb7ebbada5f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#a2701baa126589d22ff03eb7ebbada5f5">parse_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="memdesc:a2701baa126589d22ff03eb7ebbada5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an expression using the Pratt parsing algorithm.  <br /></td></tr>
<tr class="separator:a2701baa126589d22ff03eb7ebbada5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4d5835f66e6e7e08a1358b18152665" id="r_aad4d5835f66e6e7e08a1358b18152665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#aad4d5835f66e6e7e08a1358b18152665">parse_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:aad4d5835f66e6e7e08a1358b18152665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a single statement.  <br /></td></tr>
<tr class="separator:aad4d5835f66e6e7e08a1358b18152665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d4d98cf3fc80e10331bcd1d8b77e26" id="r_a16d4d98cf3fc80e10331bcd1d8b77e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8c.html#a16d4d98cf3fc80e10331bcd1d8b77e26">parse_type</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a16d4d98cf3fc80e10331bcd1d8b77e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a type annotation.  <br /></td></tr>
<tr class="separator:a16d4d98cf3fc80e10331bcd1d8b77e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the parser module for the programming language compiler. </p>
<p>This file contains the core parsing functionality that converts a stream of tokens into an Abstract Syntax Tree (AST). The parser uses a Pratt parser approach for handling operator precedence and associativity in expressions.</p>
<p>The parser supports:</p><ul>
<li>Statement parsing (variables, functions, control flow, etc.)</li>
<li>Expression parsing with proper operator precedence</li>
<li>Type parsing for type annotations</li>
<li>Error reporting with source location information</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Connor Harris </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2025 </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="abd32c60384ae40c357cc28e65fd764d1" name="abd32c60384ae40c357cc28e65fd764d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd32c60384ae40c357cc28e65fd764d1">&#9670;&#160;</a></span>get_bp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> get_bp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921">TokenType</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the binding power (precedence) for a given token type. </p>
<p>This function is crucial for the Pratt parser implementation. It returns the binding power (precedence level) for different operators, which determines the order of operations during expression parsing.</p>
<p>Higher binding power values indicate higher precedence operators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td>The token type to get binding power for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BindingPower enumeration value representing the precedence level Returns BP_NONE for tokens that don't have binding power</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Precedence levels (highest to lowest):<ul>
<li>BP_CALL: Function calls, member access, indexing</li>
<li>BP_POSTFIX: Postfix increment/decrement</li>
<li>BP_PRODUCT: Multiplication, division</li>
<li>BP_SUM: Addition, subtraction</li>
<li>BP_RELATIONAL: Comparison operators</li>
<li>BP_EQUALITY: Equality and inequality</li>
<li>BP_BITWISE_AND, BP_BITWISE_XOR, BP_BITWISE_OR: Bitwise operations</li>
<li>BP_LOGICAL_AND, BP_LOGICAL_OR: Logical operations</li>
<li>BP_TERNARY: Ternary conditional operator</li>
<li>BP_ASSIGN: Assignment operators</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e" title="Binding power (precedence) levels for expression parsing.">BindingPower</a>, <a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921" title="Enumeration of all possible token types recognized by the lexer.">TokenType</a> </dd></dl>

</div>
</div>
<a id="ad715ebb051a669c00dc55cdcd31bed2d" name="ad715ebb051a669c00dc55cdcd31bed2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad715ebb051a669c00dc55cdcd31bed2d">&#9670;&#160;</a></span>led()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * led </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Left Denotation - handles binary and postfix expressions. </p>
<p>Pratt parser function for left denotation (infix/postfix parsing).</p>
<p>This is part of the Pratt parser implementation. The "led" function handles tokens that can appear after an expression has been parsed (binary operators and postfix operators).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">left</td><td>The left operand expression (already parsed) </td></tr>
    <tr><td class="paramname">bp</td><td>The current binding power context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed expression AST node incorporating the left operand, or the original left expression if no valid LED is found</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Binary arithmetic and logical operators: +, -, *, /, ==, !=, etc.</li>
<li>Function calls: function(args)</li>
<li>Assignment: variable = value</li>
<li>Member access: object.member</li>
<li>Postfix operators: variable++, variable&ndash;</li>
<li>Array indexing: array[index]</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#a39ffb04f9526d5ee88fa488db078cbc1" title="Null Denotation - handles prefix expressions and primary expressions.">nud()</a>, <a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="parser_8h.html#aae76f2e2da0e519b78628915240200dd">binary()</a>, <a class="el" href="parser_8h.html#a77a8786dfb25898d7c4ffbc0ca8eafcf">call_expr()</a>, <a class="el" href="parser_8h.html#a683f4d2d2d297649d7b0d2d3dc3bad8e">assign_expr()</a>, <a class="el" href="parser_8h.html#a6ec4a015146e7598655f260ecb559a84">prefix_expr()</a> </dd></dl>

</div>
</div>
<a id="a39ffb04f9526d5ee88fa488db078cbc1" name="a39ffb04f9526d5ee88fa488db078cbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ffb04f9526d5ee88fa488db078cbc1">&#9670;&#160;</a></span>nud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * nud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Null Denotation - handles prefix expressions and primary expressions. </p>
<p>This is part of the Pratt parser implementation. The "nud" function handles tokens that can appear at the beginning of an expression (prefix operators and primary expressions like literals and identifiers).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed expression AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Primary expressions: numbers, strings, identifiers</li>
<li>Prefix unary operators: -, +, !, ++, &ndash;</li>
<li>Grouped expressions: (expression)</li>
<li>Array literals: [expression, ...]</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#ad715ebb051a669c00dc55cdcd31bed2d" title="Left Denotation - handles binary and postfix expressions.">led()</a>, <a class="el" href="parser_8c.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="parser_2expr_8c.html#a481c538e520948ab138a8c5b0a8324c6">primary()</a>, <a class="el" href="parser_2expr_8c.html#a517fa2b63adec675d032991a3a712572">unary()</a>, <a class="el" href="parser_2expr_8c.html#a1ecf965f76c333d977e1ffafbef4174e">grouping()</a>, <a class="el" href="parser_2expr_8c.html#ade768344c2d92f84219dfbddb9d37987">array_expr()</a> </dd></dl>

</div>
</div>
<a id="a92a3429a7335866e6d3e6da546e7dbab" name="a92a3429a7335866e6d3e6da546e7dbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a3429a7335866e6d3e6da546e7dbab">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGrowableArray.html">GrowableArray</a> *&#160;</td>
          <td class="paramname"><em>tks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structArenaAllocator.html">ArenaAllocator</a> *&#160;</td>
          <td class="paramname"><em>arena</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main parsing function that converts tokens into an AST. </p>
<p>Parses a full program from tokens into an AST of statements.</p>
<p>This is the entry point for the parser. It takes a growable array of tokens and converts them into a complete program AST node containing all parsed statements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tks</td><td>Growable array containing all tokens from the lexer </td></tr>
    <tr><td class="paramname">arena</td><td>Arena allocator for memory management during parsing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root AST node (Program node) containing all parsed statements, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function estimates the initial capacity for statements based on token count </dd>
<dd>
All memory allocations use the provided arena allocator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParser.html" title="Parser state holding token stream and current position.">Parser</a>, <a class="el" href="parser_8h.html#aad4d5835f66e6e7e08a1358b18152665" title="Parses a single statement.">parse_stmt()</a>, <a class="el" href="ast_8h.html#a60c38b33bb0195508a6cd65fb541e226">create_program_node()</a> </dd></dl>

</div>
</div>
<a id="a2701baa126589d22ff03eb7ebbada5f5" name="a2701baa126589d22ff03eb7ebbada5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2701baa126589d22ff03eb7ebbada5f5">&#9670;&#160;</a></span>parse_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * parse_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an expression using the Pratt parsing algorithm. </p>
<p>This is the core expression parsing function that implements the Pratt parser algorithm. It handles operator precedence and associativity automatically through the binding power mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">bp</td><td>Minimum binding power - only operators with higher binding power will be consumed by this call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed expression AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm works by:<ol type="1">
<li>Getting the left expression using <a class="el" href="parser_8c.html#a39ffb04f9526d5ee88fa488db078cbc1" title="Null Denotation - handles prefix expressions and primary expressions.">nud()</a></li>
<li>While the next operator has higher binding power than bp:<ul>
<li>Use <a class="el" href="parser_8c.html#ad715ebb051a669c00dc55cdcd31bed2d" title="Left Denotation - handles binary and postfix expressions.">led()</a> to extend the expression with the operator</li>
</ul>
</li>
<li>Return the final expression</li>
</ol>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#a39ffb04f9526d5ee88fa488db078cbc1" title="Null Denotation - handles prefix expressions and primary expressions.">nud()</a>, <a class="el" href="parser_8c.html#ad715ebb051a669c00dc55cdcd31bed2d" title="Left Denotation - handles binary and postfix expressions.">led()</a>, <a class="el" href="parser_8c.html#abd32c60384ae40c357cc28e65fd764d1" title="Gets the binding power (precedence) for a given token type.">get_bp()</a>, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e" title="Binding power (precedence) levels for expression parsing.">BindingPower</a> </dd></dl>

</div>
</div>
<a id="aad4d5835f66e6e7e08a1358b18152665" name="aad4d5835f66e6e7e08a1358b18152665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4d5835f66e6e7e08a1358b18152665">&#9670;&#160;</a></span>parse_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * parse_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a single statement. </p>
<p>This function dispatches to the appropriate statement parsing function based on the current token. It also handles visibility modifiers (public/private) that can appear before certain statement types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed statement AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Variable declarations: const, var</li>
<li>Control flow: return, if, loop, break, continue</li>
<li>Block statements: { ... }</li>
<li>Print statements: print, println</li>
<li>Expression statements: any expression followed by semicolon</li>
<li>Visibility modifiers: public, private (applied to declarations)</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#acd0470a765c07f4aa6855db5449e351a" title="Parses a constant declaration statement.">const_stmt()</a>, <a class="el" href="parser_8h.html#a74b60c0d077f19dca00679311b5ce1d9" title="Parses a variable declaration statement.">var_stmt()</a>, <a class="el" href="parser_8h.html#a65feab14f178a93af29954494842495c" title="Parses a return statement.">return_stmt()</a>, <a class="el" href="parser_8h.html#a398fc7e43b145f2332fbb0711e59b471" title="Parses a block statement.">block_stmt()</a>, <a class="el" href="parser_8h.html#a5a2c054597dd672f140bd9859e51da10" title="Parses if/elif/else conditional statements.">if_stmt()</a>, <a class="el" href="parser_8h.html#a116eace6cdf11c0f5a066af2e7c069b1" title="Parses loop statements (infinite, while, or for loops)">loop_stmt()</a>, <a class="el" href="parser_8h.html#a5dc127de3e1e39ab9270bd87fe3733a6" title="Parses print/println statements.">print_stmt()</a>, <a class="el" href="parser_8h.html#ab63fdeaaa163c06ed9af09d86379b060" title="Parses break and continue statements.">break_continue_stmt()</a>, <a class="el" href="parser_8h.html#a25a630a2b0ae343cd5bd2016c545a2ac" title="Parses an expression statement.">expr_stmt()</a> </dd></dl>

</div>
</div>
<a id="a16d4d98cf3fc80e10331bcd1d8b77e26" name="a16d4d98cf3fc80e10331bcd1d8b77e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d4d98cf3fc80e10331bcd1d8b77e26">&#9670;&#160;</a></span>parse_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> * parse_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a type annotation. </p>
<p>This function parses type expressions used in variable declarations, function parameters, return types, etc. It handles primitive types, pointer types, array types, and user-defined types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed Type AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Primitive types: int, uint, float, bool, string, void, char</li>
<li>Pointer types: *type</li>
<li>Array types: [size]type or []type</li>
<li>User-defined types: identified by TOK_IDENTIFIER</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Prints error message to stderr for unexpected tokens</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#a4b598fef0adda01f89712c89e337c315">tnud()</a>, <a class="el" href="parser_8h.html#ac9cffb5ed1ef3cd27b0dbcd511044919">tled()</a>, <a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921" title="Enumeration of all possible token types recognized by the lexer.">TokenType</a> </dd></dl>

</div>
</div>
<a id="a9a2a8ba5bea0c6ee41058bf6f8eb6178" name="a9a2a8ba5bea0c6ee41058bf6f8eb6178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2a8ba5bea0c6ee41058bf6f8eb6178">&#9670;&#160;</a></span>parser_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>psr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tk_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports a parser error with detailed location information. </p>
<p>Report a parser error with detailed location info.</p>
<p>Creates and adds an error to the global error system with information about where the error occurred in the source code, including line and column information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psr</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">error_type</td><td>String describing the type of error (e.g., "SyntaxError") </td></tr>
    <tr><td class="paramname">file</td><td>Path to the source file where the error occurred </td></tr>
    <tr><td class="paramname">msg</td><td>Detailed error message describing what went wrong </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the error occurred (1-based) </td></tr>
    <tr><td class="paramname">col</td><td>Column number where the error occurred (1-based) </td></tr>
    <tr><td class="paramname">tk_length</td><td>Length of the token that caused the error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function uses the arena allocator to duplicate the line text </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structErrorInformation.html" title="Stores detailed information about an error.">ErrorInformation</a>, <a class="el" href="error_8c.html#a4f3d659181bf27a69270daa8d5ab0658" title="Adds an error to the internal error list.">error_add()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
