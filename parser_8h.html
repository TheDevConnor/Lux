<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lux: src/parser/parser.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lux<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">A low-level compiled alternative to C, C++, and more!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_6cd8491d143eb218b70983dbdb3c58bc.html">parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">parser.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Recursive descent and Pratt parser for the Zura language.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ast_8h_source.html">../ast/ast.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="memory_8h_source.html">../c_libs/memory/memory.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lexer_8h_source.html">../lexer/lexer.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for parser.h:</div>
<div class="dyncontent">
<div class="center"><img src="parser_8h__incl.png" border="0" usemap="#asrc_2parser_2parser_8h" alt=""/></div>
<map name="asrc_2parser_2parser_8h" id="asrc_2parser_2parser_8h">
<area shape="rect" title="Recursive descent and Pratt parser for the Zura language." alt="" coords="77,5,219,31"/>
<area shape="rect" title=" " alt="" coords="5,225,80,251"/>
<area shape="poly" title=" " alt="" coords="114,33,79,52,64,64,52,80,39,113,34,149,35,183,40,212,34,213,30,184,29,149,34,112,47,77,60,61,76,47,111,28"/>
<area shape="rect" href="ast_8h.html" title=" " alt="" coords="61,79,152,104"/>
<area shape="poly" title=" " alt="" coords="143,32,123,68,118,65,139,30"/>
<area shape="rect" href="memory_8h.html" title="Arena allocator and growable array utilities for fast memory management." alt="" coords="143,152,342,177"/>
<area shape="poly" title=" " alt="" coords="158,30,230,139,225,142,154,33"/>
<area shape="rect" href="lexer_8h.html" title="Tokenizer (lexer) definitions and API for lexical analysis of source code." alt="" coords="227,79,341,104"/>
<area shape="poly" title=" " alt="" coords="171,28,251,70,249,75,169,33"/>
<area shape="poly" title=" " alt="" coords="104,106,56,214,51,212,99,103"/>
<area shape="rect" title=" " alt="" coords="104,225,187,251"/>
<area shape="poly" title=" " alt="" coords="112,104,141,211,136,213,107,105"/>
<area shape="poly" title=" " alt="" coords="130,102,210,143,207,148,127,106"/>
<area shape="poly" title=" " alt="" coords="211,180,89,223,88,218,210,175"/>
<area shape="poly" title=" " alt="" coords="229,180,174,219,171,215,225,175"/>
<area shape="rect" title=" " alt="" coords="211,225,298,251"/>
<area shape="poly" title=" " alt="" coords="247,177,253,211,248,212,242,178"/>
<area shape="poly" title=" " alt="" coords="279,106,259,141,254,139,275,103"/>
<area shape="rect" title=" " alt="" coords="366,152,437,177"/>
<area shape="poly" title=" " alt="" coords="304,102,372,142,369,147,301,106"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="parser_8h__dep__incl.png" border="0" usemap="#asrc_2parser_2parser_8hdep" alt=""/></div>
<map name="asrc_2parser_2parser_8hdep" id="asrc_2parser_2parser_8hdep">
<area shape="rect" title="Recursive descent and Pratt parser for the Zura language." alt="" coords="398,5,541,31"/>
<area shape="rect" href="run_8c.html" title=" " alt="" coords="5,79,128,104"/>
<area shape="poly" title=" " alt="" coords="392,36,129,82,128,77,391,30"/>
<area shape="rect" href="parser_2expr_8c.html" title="Expression parsing implementation for the programming language compiler." alt="" coords="153,79,282,104"/>
<area shape="poly" title=" " alt="" coords="416,37,259,81,257,76,415,32"/>
<area shape="rect" href="parser_8c.html" title="Implementation of the parser module for the programming language compiler." alt="" coords="307,79,448,104"/>
<area shape="poly" title=" " alt="" coords="446,41,394,81,391,76,442,37"/>
<area shape="rect" href="parser__utils_8c.html" title="Utility functions for the parser module." alt="" coords="473,79,650,104"/>
<area shape="poly" title=" " alt="" coords="496,37,548,76,545,81,493,41"/>
<area shape="rect" href="parser_2stmt_8c.html" title="Statement parsing implementation for the programming language compiler." alt="" coords="675,79,805,104"/>
<area shape="poly" title=" " alt="" coords="527,32,697,76,695,81,525,37"/>
<area shape="rect" href="parser_2type_8c.html" title=" " alt="" coords="829,79,960,104"/>
<area shape="poly" title=" " alt="" coords="552,30,830,77,829,82,551,36"/>
</map>
</div>
</div>
<p><a href="parser_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structParser.html" title="Parser state holding token stream and current position.">Parser</a> state holding token stream and current position.  <a href="structParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ace48720acc4b922f947e0d57df9b3f36" id="r_ace48720acc4b922f947e0d57df9b3f36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ace48720acc4b922f947e0d57df9b3f36">CURRENT_TOKEN_LENGTH</a>(parser)&#160;&#160;&#160;((int)<a class="el" href="parser_8h.html#a7fbcabd9ce88ca44946533a7aaaa68a4">p_current</a>(parser).length)</td></tr>
<tr class="memdesc:ace48720acc4b922f947e0d57df9b3f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the current token's lexeme.  <br /></td></tr>
<tr class="separator:ace48720acc4b922f947e0d57df9b3f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532b199d177d1142acd910987d972af5" id="r_a532b199d177d1142acd910987d972af5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a532b199d177d1142acd910987d972af5">CURRENT_TOKEN_VALUE</a>(parser)&#160;&#160;&#160;(<a class="el" href="parser_8h.html#a7fbcabd9ce88ca44946533a7aaaa68a4">p_current</a>(parser).value)</td></tr>
<tr class="memdesc:a532b199d177d1142acd910987d972af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value string of the current token.  <br /></td></tr>
<tr class="separator:a532b199d177d1142acd910987d972af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb522126225ed3fb36b61a61adac671f" id="r_acb522126225ed3fb36b61a61adac671f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#acb522126225ed3fb36b61a61adac671f">MAX_STMT</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:acb522126225ed3fb36b61a61adac671f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed size for statements, expressions, and types.  <br /></td></tr>
<tr class="separator:acb522126225ed3fb36b61a61adac671f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0279480c631d05fe94f2e0c3abf48be9" id="r_a0279480c631d05fe94f2e0c3abf48be9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a0279480c631d05fe94f2e0c3abf48be9">MAX_EXPR</a>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a0279480c631d05fe94f2e0c3abf48be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acd8ca9bc6199921957a2363589304e" id="r_a5acd8ca9bc6199921957a2363589304e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a5acd8ca9bc6199921957a2363589304e">MAX_TYPE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a5acd8ca9bc6199921957a2363589304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afda66df955be06c6d47c751fc63ebc0e" id="r_afda66df955be06c6d47c751fc63ebc0e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> { <br />
&#160;&#160;<a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eaf91e2cf40b547651cc94be830eeb5d66">BP_NONE</a> = 0
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eab8fbb9c59538d36279ed24d804c1142b">BP_LOWEST</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eac9dfa40e8c85b35b1ee1ecde6c9dab84">BP_ASSIGN</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0ea4d0216a7b11bdf2f164bb145d0e9519d">BP_TERNARY</a>
, <br />
&#160;&#160;<a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eab34041edce73ee6acdbbda2d21763d64">BP_LOGICAL_OR</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0ea7bf8515e58063fdd9a2ad3bbd9f4b9f2">BP_LOGICAL_AND</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eabdd798f8f870fbc24da133173db83642">BP_BITWISE_OR</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eac0c7a7fc256182467ccfec862085c750">BP_BITWISE_XOR</a>
, <br />
&#160;&#160;<a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eae4dea4dd68770e49ea0b3df29f54e753">BP_BITWISE_AND</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eafb9c2c22a961139dd3b0282f63dcb457">BP_EQUALITY</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eafc4a7466003927edb7c5efa928e0d5be">BP_RELATIONAL</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eac96b5a0919938ffe6889eff65a752b99">BP_SHIFT</a>
, <br />
&#160;&#160;<a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0ea1d6e5086603b3a6792e40bbf366d21d6">BP_SUM</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0ea71b4fabf103d7779fefe8fee0cdc2ce8">BP_PRODUCT</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0ea9b44a27a3bf24db283b926fed1367581">BP_EXPONENT</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0ea6edcdab7beeec914f0ea1ef863ee5a23">BP_UNARY</a>
, <br />
&#160;&#160;<a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0ea99e5516dde009010745ee6961e684067">BP_POSTFIX</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eabd0be4ce733a8a9a1865de16a82d50cf">BP_CALL</a>
, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0eabe7c83c4f13564833b4c97099e6ed10b">BP_PRIMARY</a>
<br />
 }</td></tr>
<tr class="memdesc:afda66df955be06c6d47c751fc63ebc0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binding power (precedence) levels for expression parsing.  <a href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">More...</a><br /></td></tr>
<tr class="separator:afda66df955be06c6d47c751fc63ebc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9a2a8ba5bea0c6ee41058bf6f8eb6178" id="r_a9a2a8ba5bea0c6ee41058bf6f8eb6178"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a9a2a8ba5bea0c6ee41058bf6f8eb6178">parser_error</a> (<a class="el" href="structParser.html">Parser</a> *psr, const char *error_type, const char *file, const char *msg, int line, int col, int tk_length)</td></tr>
<tr class="memdesc:a9a2a8ba5bea0c6ee41058bf6f8eb6178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report a parser error with detailed location info.  <br /></td></tr>
<tr class="separator:a9a2a8ba5bea0c6ee41058bf6f8eb6178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad438bd01c47ce6a0824f58f003cb81e5" id="r_ad438bd01c47ce6a0824f58f003cb81e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ad438bd01c47ce6a0824f58f003cb81e5">p_has_tokens</a> (<a class="el" href="structParser.html">Parser</a> *psr)</td></tr>
<tr class="memdesc:ad438bd01c47ce6a0824f58f003cb81e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are more tokens available for parsing.  <br /></td></tr>
<tr class="separator:ad438bd01c47ce6a0824f58f003cb81e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fe3f2a756479a093d29f08946c57d7" id="r_a12fe3f2a756479a093d29f08946c57d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structToken.html">Token</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a12fe3f2a756479a093d29f08946c57d7">p_peek</a> (<a class="el" href="structParser.html">Parser</a> *psr, size_t offset)</td></tr>
<tr class="memdesc:a12fe3f2a756479a093d29f08946c57d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peeks at a token at the specified offset from current position.  <br /></td></tr>
<tr class="separator:a12fe3f2a756479a093d29f08946c57d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbcabd9ce88ca44946533a7aaaa68a4" id="r_a7fbcabd9ce88ca44946533a7aaaa68a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structToken.html">Token</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a7fbcabd9ce88ca44946533a7aaaa68a4">p_current</a> (<a class="el" href="structParser.html">Parser</a> *psr)</td></tr>
<tr class="memdesc:a7fbcabd9ce88ca44946533a7aaaa68a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current token without advancing the parser position.  <br /></td></tr>
<tr class="separator:a7fbcabd9ce88ca44946533a7aaaa68a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f10f4ace5bea57b54d84c5088d349e" id="r_ab4f10f4ace5bea57b54d84c5088d349e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structToken.html">Token</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ab4f10f4ace5bea57b54d84c5088d349e">p_advance</a> (<a class="el" href="structParser.html">Parser</a> *psr)</td></tr>
<tr class="memdesc:ab4f10f4ace5bea57b54d84c5088d349e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances to the next token and returns the current token.  <br /></td></tr>
<tr class="separator:ab4f10f4ace5bea57b54d84c5088d349e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae2c122d273b1681a60ee873efe2a4f" id="r_a8ae2c122d273b1681a60ee873efe2a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structToken.html">Token</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a8ae2c122d273b1681a60ee873efe2a4f">p_consume</a> (<a class="el" href="structParser.html">Parser</a> *psr, <a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921">TokenType</a> type, const char *error_msg)</td></tr>
<tr class="memdesc:a8ae2c122d273b1681a60ee873efe2a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes a token of the expected type or reports an error.  <br /></td></tr>
<tr class="separator:a8ae2c122d273b1681a60ee873efe2a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8779384c9ac7a618c2b851cb11d1598c" id="r_a8779384c9ac7a618c2b851cb11d1598c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a8779384c9ac7a618c2b851cb11d1598c">get_name</a> (<a class="el" href="structParser.html">Parser</a> *psr)</td></tr>
<tr class="memdesc:a8779384c9ac7a618c2b851cb11d1598c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts and duplicates the current token's string value.  <br /></td></tr>
<tr class="separator:a8779384c9ac7a618c2b851cb11d1598c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a3429a7335866e6d3e6da546e7dbab" id="r_a92a3429a7335866e6d3e6da546e7dbab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a92a3429a7335866e6d3e6da546e7dbab">parse</a> (<a class="el" href="structGrowableArray.html">GrowableArray</a> *tks, <a class="el" href="structArenaAllocator.html">ArenaAllocator</a> *arena)</td></tr>
<tr class="memdesc:a92a3429a7335866e6d3e6da546e7dbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a full program from tokens into an AST of statements.  <br /></td></tr>
<tr class="separator:a92a3429a7335866e6d3e6da546e7dbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2701baa126589d22ff03eb7ebbada5f5" id="r_a2701baa126589d22ff03eb7ebbada5f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5">parse_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="memdesc:a2701baa126589d22ff03eb7ebbada5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an expression using the Pratt parsing algorithm.  <br /></td></tr>
<tr class="separator:a2701baa126589d22ff03eb7ebbada5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4d5835f66e6e7e08a1358b18152665" id="r_aad4d5835f66e6e7e08a1358b18152665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#aad4d5835f66e6e7e08a1358b18152665">parse_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:aad4d5835f66e6e7e08a1358b18152665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a single statement.  <br /></td></tr>
<tr class="separator:aad4d5835f66e6e7e08a1358b18152665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d4d98cf3fc80e10331bcd1d8b77e26" id="r_a16d4d98cf3fc80e10331bcd1d8b77e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a16d4d98cf3fc80e10331bcd1d8b77e26">parse_type</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a16d4d98cf3fc80e10331bcd1d8b77e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a type annotation.  <br /></td></tr>
<tr class="separator:a16d4d98cf3fc80e10331bcd1d8b77e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeed9749e6467fb814f1eaa0616417d" id="r_acfeed9749e6467fb814f1eaa0616417d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#acfeed9749e6467fb814f1eaa0616417d">init_parser_arrays</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="structGrowableArray.html">GrowableArray</a> *stmts, <a class="el" href="structGrowableArray.html">GrowableArray</a> *modules)</td></tr>
<tr class="separator:acfeed9749e6467fb814f1eaa0616417d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6e92eed019bfb4c14934d50c82acfe" id="r_a7e6e92eed019bfb4c14934d50c82acfe"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a7e6e92eed019bfb4c14934d50c82acfe">parse_module_declaration</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a7e6e92eed019bfb4c14934d50c82acfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ffb04f9526d5ee88fa488db078cbc1" id="r_a39ffb04f9526d5ee88fa488db078cbc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a39ffb04f9526d5ee88fa488db078cbc1">nud</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a39ffb04f9526d5ee88fa488db078cbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null Denotation - handles prefix expressions and primary expressions.  <br /></td></tr>
<tr class="separator:a39ffb04f9526d5ee88fa488db078cbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad715ebb051a669c00dc55cdcd31bed2d" id="r_ad715ebb051a669c00dc55cdcd31bed2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ad715ebb051a669c00dc55cdcd31bed2d">led</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="memdesc:ad715ebb051a669c00dc55cdcd31bed2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pratt parser function for left denotation (infix/postfix parsing).  <br /></td></tr>
<tr class="separator:ad715ebb051a669c00dc55cdcd31bed2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd32c60384ae40c357cc28e65fd764d1" id="r_abd32c60384ae40c357cc28e65fd764d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#abd32c60384ae40c357cc28e65fd764d1">get_bp</a> (<a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921">TokenType</a> kind)</td></tr>
<tr class="memdesc:abd32c60384ae40c357cc28e65fd764d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the binding power (precedence) for a given token type.  <br /></td></tr>
<tr class="separator:abd32c60384ae40c357cc28e65fd764d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481c538e520948ab138a8c5b0a8324c6" id="r_a481c538e520948ab138a8c5b0a8324c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a481c538e520948ab138a8c5b0a8324c6">primary</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a481c538e520948ab138a8c5b0a8324c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517fa2b63adec675d032991a3a712572" id="r_a517fa2b63adec675d032991a3a712572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a517fa2b63adec675d032991a3a712572">unary</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a517fa2b63adec675d032991a3a712572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecf965f76c333d977e1ffafbef4174e" id="r_a1ecf965f76c333d977e1ffafbef4174e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a1ecf965f76c333d977e1ffafbef4174e">grouping</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a1ecf965f76c333d977e1ffafbef4174e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae76f2e2da0e519b78628915240200dd" id="r_aae76f2e2da0e519b78628915240200dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#aae76f2e2da0e519b78628915240200dd">binary</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="separator:aae76f2e2da0e519b78628915240200dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a8786dfb25898d7c4ffbc0ca8eafcf" id="r_a77a8786dfb25898d7c4ffbc0ca8eafcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a77a8786dfb25898d7c4ffbc0ca8eafcf">call_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="separator:a77a8786dfb25898d7c4ffbc0ca8eafcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683f4d2d2d297649d7b0d2d3dc3bad8e" id="r_a683f4d2d2d297649d7b0d2d3dc3bad8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a683f4d2d2d297649d7b0d2d3dc3bad8e">assign_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="separator:a683f4d2d2d297649d7b0d2d3dc3bad8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec4a015146e7598655f260ecb559a84" id="r_a6ec4a015146e7598655f260ecb559a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a6ec4a015146e7598655f260ecb559a84">prefix_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="separator:a6ec4a015146e7598655f260ecb559a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade768344c2d92f84219dfbddb9d37987" id="r_ade768344c2d92f84219dfbddb9d37987"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ade768344c2d92f84219dfbddb9d37987">array_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:ade768344c2d92f84219dfbddb9d37987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303249537dc9f4b1af6c42f111296ad2" id="r_a303249537dc9f4b1af6c42f111296ad2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a303249537dc9f4b1af6c42f111296ad2">deref_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a303249537dc9f4b1af6c42f111296ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2701a3c0f8bdb64568ddf8a847a5a53" id="r_ad2701a3c0f8bdb64568ddf8a847a5a53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ad2701a3c0f8bdb64568ddf8a847a5a53">addr_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:ad2701a3c0f8bdb64568ddf8a847a5a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7c02ae33ac8ff5f65ef4eeb90db02e" id="r_a9e7c02ae33ac8ff5f65ef4eeb90db02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a9e7c02ae33ac8ff5f65ef4eeb90db02e">alloc_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a9e7c02ae33ac8ff5f65ef4eeb90db02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d6ab71810f245f89f55deefef54328" id="r_a23d6ab71810f245f89f55deefef54328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a23d6ab71810f245f89f55deefef54328">memcpy_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a23d6ab71810f245f89f55deefef54328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7f76374e76cb0765849eb1890aaa35" id="r_a7a7f76374e76cb0765849eb1890aaa35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a7a7f76374e76cb0765849eb1890aaa35">free_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a7a7f76374e76cb0765849eb1890aaa35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98faa3315b62a06d6aef0c9d84a5aaf0" id="r_a98faa3315b62a06d6aef0c9d84a5aaf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a98faa3315b62a06d6aef0c9d84a5aaf0">cast_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a98faa3315b62a06d6aef0c9d84a5aaf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b72b6b4d03c16bc1c17d7eaa62b5fc" id="r_ac7b72b6b4d03c16bc1c17d7eaa62b5fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ac7b72b6b4d03c16bc1c17d7eaa62b5fc">sizeof_expr</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:ac7b72b6b4d03c16bc1c17d7eaa62b5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b598fef0adda01f89712c89e337c315" id="r_a4b598fef0adda01f89712c89e337c315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a4b598fef0adda01f89712c89e337c315">tnud</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a4b598fef0adda01f89712c89e337c315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9cffb5ed1ef3cd27b0dbcd511044919" id="r_ac9cffb5ed1ef3cd27b0dbcd511044919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ac9cffb5ed1ef3cd27b0dbcd511044919">tled</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> *left, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> bp)</td></tr>
<tr class="separator:ac9cffb5ed1ef3cd27b0dbcd511044919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6127fb2a8cfbdfe0e3264ac97bfe75e" id="r_ac6127fb2a8cfbdfe0e3264ac97bfe75e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ac6127fb2a8cfbdfe0e3264ac97bfe75e">tget_bp</a> (<a class="el" href="structParser.html">Parser</a> *parser, <a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921">TokenType</a> kind)</td></tr>
<tr class="separator:ac6127fb2a8cfbdfe0e3264ac97bfe75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4710c0018883a69cd385b596a1cc5d0b" id="r_a4710c0018883a69cd385b596a1cc5d0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a4710c0018883a69cd385b596a1cc5d0b">pointer</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a4710c0018883a69cd385b596a1cc5d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561d9218dbfa2240b1a31113835acb26" id="r_a561d9218dbfa2240b1a31113835acb26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a561d9218dbfa2240b1a31113835acb26">array_type</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a561d9218dbfa2240b1a31113835acb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dad6cf3360477655b7a6f8667b8ab78" id="r_a9dad6cf3360477655b7a6f8667b8ab78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a9dad6cf3360477655b7a6f8667b8ab78">use_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a9dad6cf3360477655b7a6f8667b8ab78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a630a2b0ae343cd5bd2016c545a2ac" id="r_a25a630a2b0ae343cd5bd2016c545a2ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a25a630a2b0ae343cd5bd2016c545a2ac">expr_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a25a630a2b0ae343cd5bd2016c545a2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an expression statement.  <br /></td></tr>
<tr class="separator:a25a630a2b0ae343cd5bd2016c545a2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b60c0d077f19dca00679311b5ce1d9" id="r_a74b60c0d077f19dca00679311b5ce1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a74b60c0d077f19dca00679311b5ce1d9">var_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser, bool is_public)</td></tr>
<tr class="memdesc:a74b60c0d077f19dca00679311b5ce1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a variable declaration statement.  <br /></td></tr>
<tr class="separator:a74b60c0d077f19dca00679311b5ce1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0470a765c07f4aa6855db5449e351a" id="r_acd0470a765c07f4aa6855db5449e351a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#acd0470a765c07f4aa6855db5449e351a">const_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser, bool is_public)</td></tr>
<tr class="memdesc:acd0470a765c07f4aa6855db5449e351a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a constant declaration statement.  <br /></td></tr>
<tr class="separator:acd0470a765c07f4aa6855db5449e351a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d805e55bb21e6bc022ed7a418445cbe" id="r_a1d805e55bb21e6bc022ed7a418445cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a1d805e55bb21e6bc022ed7a418445cbe">fn_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser, const char *name, bool is_public)</td></tr>
<tr class="memdesc:a1d805e55bb21e6bc022ed7a418445cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a function declaration statement.  <br /></td></tr>
<tr class="separator:a1d805e55bb21e6bc022ed7a418445cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d0cb28037eca83f6e6326afee5e4c7" id="r_ae6d0cb28037eca83f6e6326afee5e4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ae6d0cb28037eca83f6e6326afee5e4c7">enum_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser, const char *name, bool is_public)</td></tr>
<tr class="memdesc:ae6d0cb28037eca83f6e6326afee5e4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an enumeration declaration statement.  <br /></td></tr>
<tr class="separator:ae6d0cb28037eca83f6e6326afee5e4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1d180c582c2a00245cc9c146764c16" id="r_a0b1d180c582c2a00245cc9c146764c16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a0b1d180c582c2a00245cc9c146764c16">struct_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser, const char *name, bool is_public)</td></tr>
<tr class="memdesc:a0b1d180c582c2a00245cc9c146764c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a structure declaration statement.  <br /></td></tr>
<tr class="separator:a0b1d180c582c2a00245cc9c146764c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc127de3e1e39ab9270bd87fe3733a6" id="r_a5dc127de3e1e39ab9270bd87fe3733a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a5dc127de3e1e39ab9270bd87fe3733a6">print_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser, bool ln)</td></tr>
<tr class="memdesc:a5dc127de3e1e39ab9270bd87fe3733a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses print/println statements.  <br /></td></tr>
<tr class="separator:a5dc127de3e1e39ab9270bd87fe3733a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65feab14f178a93af29954494842495c" id="r_a65feab14f178a93af29954494842495c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a65feab14f178a93af29954494842495c">return_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a65feab14f178a93af29954494842495c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a return statement.  <br /></td></tr>
<tr class="separator:a65feab14f178a93af29954494842495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398fc7e43b145f2332fbb0711e59b471" id="r_a398fc7e43b145f2332fbb0711e59b471"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a398fc7e43b145f2332fbb0711e59b471">block_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a398fc7e43b145f2332fbb0711e59b471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a block statement.  <br /></td></tr>
<tr class="separator:a398fc7e43b145f2332fbb0711e59b471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733ecd3287cefe3f8128a70d3db2e0fd" id="r_a733ecd3287cefe3f8128a70d3db2e0fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a733ecd3287cefe3f8128a70d3db2e0fd">infinite_loop_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser, int line, int col)</td></tr>
<tr class="memdesc:a733ecd3287cefe3f8128a70d3db2e0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses an infinite loop statement.  <br /></td></tr>
<tr class="separator:a733ecd3287cefe3f8128a70d3db2e0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3453df19c4bcb4b00371410abf3962e0" id="r_a3453df19c4bcb4b00371410abf3962e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a3453df19c4bcb4b00371410abf3962e0">for_loop_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser, int line, int col)</td></tr>
<tr class="memdesc:a3453df19c4bcb4b00371410abf3962e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a for loop statement.  <br /></td></tr>
<tr class="separator:a3453df19c4bcb4b00371410abf3962e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116eace6cdf11c0f5a066af2e7c069b1" id="r_a116eace6cdf11c0f5a066af2e7c069b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a116eace6cdf11c0f5a066af2e7c069b1">loop_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a116eace6cdf11c0f5a066af2e7c069b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses loop statements (infinite, while, or for loops)  <br /></td></tr>
<tr class="separator:a116eace6cdf11c0f5a066af2e7c069b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2c054597dd672f140bd9859e51da10" id="r_a5a2c054597dd672f140bd9859e51da10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a5a2c054597dd672f140bd9859e51da10">if_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="memdesc:a5a2c054597dd672f140bd9859e51da10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses if/elif/else conditional statements.  <br /></td></tr>
<tr class="separator:a5a2c054597dd672f140bd9859e51da10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63fdeaaa163c06ed9af09d86379b060" id="r_ab63fdeaaa163c06ed9af09d86379b060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#ab63fdeaaa163c06ed9af09d86379b060">break_continue_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser, bool is_continue)</td></tr>
<tr class="memdesc:ab63fdeaaa163c06ed9af09d86379b060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses break and continue statements.  <br /></td></tr>
<tr class="separator:ab63fdeaaa163c06ed9af09d86379b060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b58f18074a01b4cce30dd3de8cfa06c" id="r_a4b58f18074a01b4cce30dd3de8cfa06c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#a4b58f18074a01b4cce30dd3de8cfa06c">defer_stmt</a> (<a class="el" href="structParser.html">Parser</a> *parser)</td></tr>
<tr class="separator:a4b58f18074a01b4cce30dd3de8cfa06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Recursive descent and Pratt parser for the Zura language. </p>
<p>This module implements parsing of tokens into an Abstract Syntax Tree (AST), handling expressions, statements, types, and error reporting. The parser uses binding power (precedence) to correctly parse expressions.</p>
<p>The parser supports:</p><ul>
<li>Parsing expressions with Pratt parsing techniques (nud/led functions).</li>
<li>Parsing statements including variable declarations, functions, loops, etc.</li>
<li>Parsing types including pointers and arrays.</li>
<li>Error reporting with detailed location info.</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Connor Harris </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2025 </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ace48720acc4b922f947e0d57df9b3f36" name="ace48720acc4b922f947e0d57df9b3f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace48720acc4b922f947e0d57df9b3f36">&#9670;&#160;</a></span>CURRENT_TOKEN_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CURRENT_TOKEN_LENGTH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parser</td><td>)</td>
          <td>&#160;&#160;&#160;((int)<a class="el" href="parser_8h.html#a7fbcabd9ce88ca44946533a7aaaa68a4">p_current</a>(parser).length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of the current token's lexeme. </p>

</div>
</div>
<a id="a532b199d177d1142acd910987d972af5" name="a532b199d177d1142acd910987d972af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532b199d177d1142acd910987d972af5">&#9670;&#160;</a></span>CURRENT_TOKEN_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CURRENT_TOKEN_VALUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">parser</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="parser_8h.html#a7fbcabd9ce88ca44946533a7aaaa68a4">p_current</a>(parser).value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value string of the current token. </p>

</div>
</div>
<a id="a0279480c631d05fe94f2e0c3abf48be9" name="a0279480c631d05fe94f2e0c3abf48be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0279480c631d05fe94f2e0c3abf48be9">&#9670;&#160;</a></span>MAX_EXPR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_EXPR&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb522126225ed3fb36b61a61adac671f" name="acb522126225ed3fb36b61a61adac671f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb522126225ed3fb36b61a61adac671f">&#9670;&#160;</a></span>MAX_STMT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_STMT&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum allowed size for statements, expressions, and types. </p>

</div>
</div>
<a id="a5acd8ca9bc6199921957a2363589304e" name="a5acd8ca9bc6199921957a2363589304e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acd8ca9bc6199921957a2363589304e">&#9670;&#160;</a></span>MAX_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_TYPE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afda66df955be06c6d47c751fc63ebc0e" name="afda66df955be06c6d47c751fc63ebc0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda66df955be06c6d47c751fc63ebc0e">&#9670;&#160;</a></span>BindingPower</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binding power (precedence) levels for expression parsing. </p>
<p>Used to control operator precedence and associativity in Pratt parsing. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eaf91e2cf40b547651cc94be830eeb5d66" name="afda66df955be06c6d47c751fc63ebc0eaf91e2cf40b547651cc94be830eeb5d66"></a>BP_NONE&#160;</td><td class="fielddoc"><p>No binding power </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eab8fbb9c59538d36279ed24d804c1142b" name="afda66df955be06c6d47c751fc63ebc0eab8fbb9c59538d36279ed24d804c1142b"></a>BP_LOWEST&#160;</td><td class="fielddoc"><p>Lowest binding power </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eac9dfa40e8c85b35b1ee1ecde6c9dab84" name="afda66df955be06c6d47c751fc63ebc0eac9dfa40e8c85b35b1ee1ecde6c9dab84"></a>BP_ASSIGN&#160;</td><td class="fielddoc"><p>Assignment operators (=, +=, etc.) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0ea4d0216a7b11bdf2f164bb145d0e9519d" name="afda66df955be06c6d47c751fc63ebc0ea4d0216a7b11bdf2f164bb145d0e9519d"></a>BP_TERNARY&#160;</td><td class="fielddoc"><p>Ternary conditional operator (? :) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eab34041edce73ee6acdbbda2d21763d64" name="afda66df955be06c6d47c751fc63ebc0eab34041edce73ee6acdbbda2d21763d64"></a>BP_LOGICAL_OR&#160;</td><td class="fielddoc"><p>Logical OR operator (||) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0ea7bf8515e58063fdd9a2ad3bbd9f4b9f2" name="afda66df955be06c6d47c751fc63ebc0ea7bf8515e58063fdd9a2ad3bbd9f4b9f2"></a>BP_LOGICAL_AND&#160;</td><td class="fielddoc"><p>Logical AND operator (&amp;&amp;) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eabdd798f8f870fbc24da133173db83642" name="afda66df955be06c6d47c751fc63ebc0eabdd798f8f870fbc24da133173db83642"></a>BP_BITWISE_OR&#160;</td><td class="fielddoc"><p>Bitwise OR operator (|) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eac0c7a7fc256182467ccfec862085c750" name="afda66df955be06c6d47c751fc63ebc0eac0c7a7fc256182467ccfec862085c750"></a>BP_BITWISE_XOR&#160;</td><td class="fielddoc"><p>Bitwise XOR operator (^) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eae4dea4dd68770e49ea0b3df29f54e753" name="afda66df955be06c6d47c751fc63ebc0eae4dea4dd68770e49ea0b3df29f54e753"></a>BP_BITWISE_AND&#160;</td><td class="fielddoc"><p>Bitwise AND operator (&amp;) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eafb9c2c22a961139dd3b0282f63dcb457" name="afda66df955be06c6d47c751fc63ebc0eafb9c2c22a961139dd3b0282f63dcb457"></a>BP_EQUALITY&#160;</td><td class="fielddoc"><p>Equality operators (==, !=) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eafc4a7466003927edb7c5efa928e0d5be" name="afda66df955be06c6d47c751fc63ebc0eafc4a7466003927edb7c5efa928e0d5be"></a>BP_RELATIONAL&#160;</td><td class="fielddoc"><p>Relational operators (&lt;, &gt;, &lt;=, &gt;=) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eac96b5a0919938ffe6889eff65a752b99" name="afda66df955be06c6d47c751fc63ebc0eac96b5a0919938ffe6889eff65a752b99"></a>BP_SHIFT&#160;</td><td class="fielddoc"><p>Shift operators (&lt;&lt;, &gt;&gt;) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0ea1d6e5086603b3a6792e40bbf366d21d6" name="afda66df955be06c6d47c751fc63ebc0ea1d6e5086603b3a6792e40bbf366d21d6"></a>BP_SUM&#160;</td><td class="fielddoc"><p>Addition and subtraction (+, -) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0ea71b4fabf103d7779fefe8fee0cdc2ce8" name="afda66df955be06c6d47c751fc63ebc0ea71b4fabf103d7779fefe8fee0cdc2ce8"></a>BP_PRODUCT&#160;</td><td class="fielddoc"><p>Multiplication, division, modulo (*, /, %) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0ea9b44a27a3bf24db283b926fed1367581" name="afda66df955be06c6d47c751fc63ebc0ea9b44a27a3bf24db283b926fed1367581"></a>BP_EXPONENT&#160;</td><td class="fielddoc"><p>Exponentiation operator (**) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0ea6edcdab7beeec914f0ea1ef863ee5a23" name="afda66df955be06c6d47c751fc63ebc0ea6edcdab7beeec914f0ea1ef863ee5a23"></a>BP_UNARY&#160;</td><td class="fielddoc"><p>Unary operators (!, ~, +, -, prefix ++/&ndash;) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0ea99e5516dde009010745ee6961e684067" name="afda66df955be06c6d47c751fc63ebc0ea99e5516dde009010745ee6961e684067"></a>BP_POSTFIX&#160;</td><td class="fielddoc"><p>Postfix operators (++/&ndash; postfix) </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eabd0be4ce733a8a9a1865de16a82d50cf" name="afda66df955be06c6d47c751fc63ebc0eabd0be4ce733a8a9a1865de16a82d50cf"></a>BP_CALL&#160;</td><td class="fielddoc"><p>Function call or indexing </p>
</td></tr>
<tr><td class="fieldname"><a id="afda66df955be06c6d47c751fc63ebc0eabe7c83c4f13564833b4c97099e6ed10b" name="afda66df955be06c6d47c751fc63ebc0eabe7c83c4f13564833b4c97099e6ed10b"></a>BP_PRIMARY&#160;</td><td class="fielddoc"><p>Primary expressions (literals, variables) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad2701a3c0f8bdb64568ddf8a847a5a53" name="ad2701a3c0f8bdb64568ddf8a847a5a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2701a3c0f8bdb64568ddf8a847a5a53">&#9670;&#160;</a></span>addr_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * addr_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e7c02ae33ac8ff5f65ef4eeb90db02e" name="a9e7c02ae33ac8ff5f65ef4eeb90db02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7c02ae33ac8ff5f65ef4eeb90db02e">&#9670;&#160;</a></span>alloc_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * alloc_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade768344c2d92f84219dfbddb9d37987" name="ade768344c2d92f84219dfbddb9d37987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade768344c2d92f84219dfbddb9d37987">&#9670;&#160;</a></span>array_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * array_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a561d9218dbfa2240b1a31113835acb26" name="a561d9218dbfa2240b1a31113835acb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561d9218dbfa2240b1a31113835acb26">&#9670;&#160;</a></span>array_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> * array_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a683f4d2d2d297649d7b0d2d3dc3bad8e" name="a683f4d2d2d297649d7b0d2d3dc3bad8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a683f4d2d2d297649d7b0d2d3dc3bad8e">&#9670;&#160;</a></span>assign_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * assign_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae76f2e2da0e519b78628915240200dd" name="aae76f2e2da0e519b78628915240200dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae76f2e2da0e519b78628915240200dd">&#9670;&#160;</a></span>binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * binary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a398fc7e43b145f2332fbb0711e59b471" name="a398fc7e43b145f2332fbb0711e59b471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398fc7e43b145f2332fbb0711e59b471">&#9670;&#160;</a></span>block_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * block_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a block statement. </p>
<p>Handles block statements with the syntax: <code>{ statement1; statement2; ... }</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the block statement AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Empty blocks are allowed and create a valid block statement with 0 statements </dd>
<dd>
Each statement in the block is parsed recursively using <a class="el" href="parser_8c.html#aad4d5835f66e6e7e08a1358b18152665" title="Parses a single statement.">parse_stmt()</a> </dd>
<dd>
Handles memory allocation for the statement array using growable arrays </dd>
<dd>
Continues parsing on individual statement failures (for error recovery)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#aad4d5835f66e6e7e08a1358b18152665" title="Parses a single statement.">parse_stmt()</a>, <a class="el" href="ast_8h.html#a4b6dd8ee39bf3322ff5b72a72043b952">create_block_stmt()</a> </dd></dl>

</div>
</div>
<a id="ab63fdeaaa163c06ed9af09d86379b060" name="ab63fdeaaa163c06ed9af09d86379b060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63fdeaaa163c06ed9af09d86379b060">&#9670;&#160;</a></span>break_continue_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * break_continue_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_continue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses break and continue statements. </p>
<p>Handles loop control statements with the syntax:</p><ul>
<li><code>break;</code> - Exit the current loop</li>
<li><code>continue;</code> - Skip to the next iteration of the current loop</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">is_continue</td><td>Whether this is a continue (true) or break (false) statement</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the break/continue statement AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Both statements require semicolon terminators </dd>
<dd>
These statements are only valid within loop contexts (enforced at semantic analysis) </dd>
<dd>
Break exits the innermost enclosing loop </dd>
<dd>
Continue skips to the next iteration of the innermost enclosing loop</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ast_8h.html#a78d2104b91bf39995ecd1116aa617391">create_break_continue_stmt()</a> </dd></dl>

</div>
</div>
<a id="a77a8786dfb25898d7c4ffbc0ca8eafcf" name="a77a8786dfb25898d7c4ffbc0ca8eafcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a8786dfb25898d7c4ffbc0ca8eafcf">&#9670;&#160;</a></span>call_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * call_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98faa3315b62a06d6aef0c9d84a5aaf0" name="a98faa3315b62a06d6aef0c9d84a5aaf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98faa3315b62a06d6aef0c9d84a5aaf0">&#9670;&#160;</a></span>cast_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * cast_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd0470a765c07f4aa6855db5449e351a" name="acd0470a765c07f4aa6855db5449e351a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd0470a765c07f4aa6855db5449e351a">&#9670;&#160;</a></span>const_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * const_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_public</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a constant declaration statement. </p>
<p>Handles multiple forms of constant declarations:</p><ul>
<li><code>const name: Type = value;</code> - Explicit type annotation</li>
<li><code>const name = fn ...</code> - Function declaration</li>
<li><code>const name = struct ...</code> - Struct declaration <br  />
</li>
<li><code>const name = enum ...</code> - Enum declaration</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">is_public</td><td>Whether this declaration has public visibility</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the appropriate declaration statement AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For simple constants, creates a variable declaration with immutable flag </dd>
<dd>
For complex types (functions, structs, enums), delegates to specialized parsers </dd>
<dd>
If no type is specified, it defaults to the type of the value</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_2stmt_8c.html#a1d805e55bb21e6bc022ed7a418445cbe" title="Parses a function declaration statement.">fn_stmt()</a>, <a class="el" href="parser_2stmt_8c.html#a0b1d180c582c2a00245cc9c146764c16" title="Parses a structure declaration statement.">struct_stmt()</a>, <a class="el" href="parser_2stmt_8c.html#ae6d0cb28037eca83f6e6326afee5e4c7" title="Parses an enumeration declaration statement.">enum_stmt()</a>, <a class="el" href="ast_8h.html#a4cda058317dc36ea7f21ddb85a0bd142">create_var_decl_stmt()</a> </dd></dl>

</div>
</div>
<a id="a4b58f18074a01b4cce30dd3de8cfa06c" name="a4b58f18074a01b4cce30dd3de8cfa06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b58f18074a01b4cce30dd3de8cfa06c">&#9670;&#160;</a></span>defer_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * defer_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a303249537dc9f4b1af6c42f111296ad2" name="a303249537dc9f4b1af6c42f111296ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303249537dc9f4b1af6c42f111296ad2">&#9670;&#160;</a></span>deref_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * deref_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6d0cb28037eca83f6e6326afee5e4c7" name="ae6d0cb28037eca83f6e6326afee5e4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d0cb28037eca83f6e6326afee5e4c7">&#9670;&#160;</a></span>enum_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * enum_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_public</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an enumeration declaration statement. </p>
<p>Handles enum declarations with the syntax: <code>enum { member1, member2, member3, ... };</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">name</td><td>Enum name (already parsed by caller) </td></tr>
    <tr><td class="paramname">is_public</td><td>Whether this enum has public visibility</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the enum declaration AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Enum members are identifiers separated by commas </dd>
<dd>
Trailing commas are allowed but not required </dd>
<dd>
Requires a semicolon terminator after the closing brace</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ast_8h.html#a8d0892096b8ad36acb26511899af8ab9">create_enum_decl_stmt()</a> </dd></dl>

</div>
</div>
<a id="a25a630a2b0ae343cd5bd2016c545a2ac" name="a25a630a2b0ae343cd5bd2016c545a2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a630a2b0ae343cd5bd2016c545a2ac">&#9670;&#160;</a></span>expr_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * expr_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an expression statement. </p>
<p>An expression statement consists of any expression followed by a semicolon. This is used for statements that evaluate an expression for its side effects, such as function calls or assignment expressions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created expression statement AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Captures line and column information at the start of parsing </dd>
<dd>
Requires a semicolon terminator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="ast_8h.html#a6f4fb0b4c5f6ece63493dfaa38ffa49f">create_expr_stmt()</a> </dd></dl>

</div>
</div>
<a id="a1d805e55bb21e6bc022ed7a418445cbe" name="a1d805e55bb21e6bc022ed7a418445cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d805e55bb21e6bc022ed7a418445cbe">&#9670;&#160;</a></span>fn_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * fn_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_public</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a function declaration statement. </p>
<p>Handles function declarations with the syntax: <code>fn(param1: Type1, param2: Type2, ...) ReturnType { body }</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">name</td><td>Function name (already parsed by caller) </td></tr>
    <tr><td class="paramname">is_public</td><td>Whether this function has public visibility</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the function declaration AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Function parameters are stored as parallel arrays of names and types </dd>
<dd>
Return type is required and parsed after the parameter list </dd>
<dd>
Function body must be a block statement </dd>
<dd>
Memory for parameter arrays is allocated using the arena allocator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#a16d4d98cf3fc80e10331bcd1d8b77e26" title="Parses a type annotation.">parse_type()</a>, <a class="el" href="parser_2stmt_8c.html#a398fc7e43b145f2332fbb0711e59b471" title="Parses a block statement.">block_stmt()</a>, <a class="el" href="ast_8h.html#a7a80f1f818e59af30946fb78bccbdc08">create_func_decl_stmt()</a> </dd></dl>

</div>
</div>
<a id="a3453df19c4bcb4b00371410abf3962e0" name="a3453df19c4bcb4b00371410abf3962e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3453df19c4bcb4b00371410abf3962e0">&#9670;&#160;</a></span>for_loop_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * for_loop_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a for loop statement. </p>
<p>Handles for loops with the syntax: </p><div class="fragment"><div class="line">loop [i: <span class="keywordtype">int</span> = 0, j: <span class="keywordtype">int</span> = 1](condition) { ... }</div>
<div class="line">loop [i: <span class="keywordtype">int</span> = 0, j: <span class="keywordtype">int</span> = 1](condition) : (optional_condition) { ... }</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the loop statement starts </td></tr>
    <tr><td class="paramname">col</td><td>Column number where the loop statement starts</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the for loop statement AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supports multiple initializer variables separated by commas </dd>
<dd>
Main condition is required and parenthesized </dd>
<dd>
Optional secondary condition can be provided after a colon </dd>
<dd>
Loop body must be a block statement</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_2stmt_8c.html#a5284c9cf5b5109eba774765169161808" title="Parses a loop initializer declaration.">loop_init()</a>, <a class="el" href="parser_8c.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="parser_2stmt_8c.html#a398fc7e43b145f2332fbb0711e59b471" title="Parses a block statement.">block_stmt()</a>, <a class="el" href="ast_8h.html#ac3fbdea59dc3076b3651d6b7aa7b3911">create_for_loop_stmt()</a> </dd></dl>

</div>
</div>
<a id="a7a7f76374e76cb0765849eb1890aaa35" name="a7a7f76374e76cb0765849eb1890aaa35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7f76374e76cb0765849eb1890aaa35">&#9670;&#160;</a></span>free_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * free_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd32c60384ae40c357cc28e65fd764d1" name="abd32c60384ae40c357cc28e65fd764d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd32c60384ae40c357cc28e65fd764d1">&#9670;&#160;</a></span>get_bp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> get_bp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921">TokenType</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the binding power (precedence) for a given token type. </p>
<p>This function is crucial for the Pratt parser implementation. It returns the binding power (precedence level) for different operators, which determines the order of operations during expression parsing.</p>
<p>Higher binding power values indicate higher precedence operators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kind</td><td>The token type to get binding power for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BindingPower enumeration value representing the precedence level Returns BP_NONE for tokens that don't have binding power</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Precedence levels (highest to lowest):<ul>
<li>BP_CALL: Function calls, member access, indexing</li>
<li>BP_POSTFIX: Postfix increment/decrement</li>
<li>BP_PRODUCT: Multiplication, division</li>
<li>BP_SUM: Addition, subtraction</li>
<li>BP_RELATIONAL: Comparison operators</li>
<li>BP_EQUALITY: Equality and inequality</li>
<li>BP_BITWISE_AND, BP_BITWISE_XOR, BP_BITWISE_OR: Bitwise operations</li>
<li>BP_LOGICAL_AND, BP_LOGICAL_OR: Logical operations</li>
<li>BP_TERNARY: Ternary conditional operator</li>
<li>BP_ASSIGN: Assignment operators</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e" title="Binding power (precedence) levels for expression parsing.">BindingPower</a>, <a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921" title="Enumeration of all possible token types recognized by the lexer.">TokenType</a> </dd></dl>

</div>
</div>
<a id="a8779384c9ac7a618c2b851cb11d1598c" name="a8779384c9ac7a618c2b851cb11d1598c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8779384c9ac7a618c2b851cb11d1598c">&#9670;&#160;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * get_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>psr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts and duplicates the current token's string value. </p>
<p>This function creates a null-terminated string copy of the current token's value using the arena allocator. It's primarily used for extracting identifier names, string literals, and other textual token content that needs to be preserved in the AST.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psr</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a null-terminated string containing the current token's value, allocated using the parser's arena allocator</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The returned string is allocated using <a class="el" href="memory_8c.html#a4a743cb5b88ba3486983a0dad9c46932" title="Allocates memory from the arena allocator with automatic buffer growth.">arena_alloc()</a> for automatic memory management </dd>
<dd>
The string is properly null-terminated for safe use with standard string functions </dd>
<dd>
The original token value is copied, so the returned string is independent </dd>
<dd>
Memory is automatically managed by the arena - no manual deallocation needed</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function assumes the current token has a valid value field </dd>
<dd>
Should only be called when you know the current token contains string data</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#a532b199d177d1142acd910987d972af5" title="Get the value string of the current token.">CURRENT_TOKEN_VALUE()</a>, <a class="el" href="parser_8h.html#ace48720acc4b922f947e0d57df9b3f36" title="Get the length of the current token&#39;s lexeme.">CURRENT_TOKEN_LENGTH()</a>, <a class="el" href="memory_8c.html#a4a743cb5b88ba3486983a0dad9c46932" title="Allocates memory from the arena allocator with automatic buffer growth.">arena_alloc()</a> </dd></dl>

</div>
</div>
<a id="a1ecf965f76c333d977e1ffafbef4174e" name="a1ecf965f76c333d977e1ffafbef4174e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecf965f76c333d977e1ffafbef4174e">&#9670;&#160;</a></span>grouping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * grouping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a2c054597dd672f140bd9859e51da10" name="a5a2c054597dd672f140bd9859e51da10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2c054597dd672f140bd9859e51da10">&#9670;&#160;</a></span>if_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * if_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses if/elif/else conditional statements. </p>
<p>Handles complex conditional statements with multiple branches: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (condition1) { ... }</div>
<div class="line">elif (condition2) { ... }</div>
<div class="line">elif (condition3) { ... }</div>
<div class="line"><span class="keywordflow">else</span> { ... }</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the if statement AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supports multiple elif clauses </dd>
<dd>
Else clause is optional </dd>
<dd>
Each condition must be parenthesized </dd>
<dd>
Each branch must be a block statement </dd>
<dd>
Elif statements are collected in an array rather than nested recursively</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="parser_2stmt_8c.html#a398fc7e43b145f2332fbb0711e59b471" title="Parses a block statement.">block_stmt()</a>, <a class="el" href="ast_8h.html#abd68c7483a6120a06b4b408eadd4965e">create_if_stmt()</a> </dd></dl>

</div>
</div>
<a id="a733ecd3287cefe3f8128a70d3db2e0fd" name="a733ecd3287cefe3f8128a70d3db2e0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733ecd3287cefe3f8128a70d3db2e0fd">&#9670;&#160;</a></span>infinite_loop_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * infinite_loop_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an infinite loop statement. </p>
<p>Handles infinite loops with the syntax: <code>loop { ... }</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the loop statement starts </td></tr>
    <tr><td class="paramname">col</td><td>Column number where the loop statement starts</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the infinite loop statement AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The loop body must be a block statement </dd>
<dd>
This creates a loop that runs indefinitely unless broken by break/return</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_2stmt_8c.html#a398fc7e43b145f2332fbb0711e59b471" title="Parses a block statement.">block_stmt()</a>, <a class="el" href="ast_8h.html#a887c557131cd93997884c28885168ee7">create_infinite_loop_stmt()</a> </dd></dl>

</div>
</div>
<a id="acfeed9749e6467fb814f1eaa0616417d" name="acfeed9749e6467fb814f1eaa0616417d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfeed9749e6467fb814f1eaa0616417d">&#9670;&#160;</a></span>init_parser_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool init_parser_arrays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGrowableArray.html">GrowableArray</a> *&#160;</td>
          <td class="paramname"><em>stmts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structGrowableArray.html">GrowableArray</a> *&#160;</td>
          <td class="paramname"><em>modules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad715ebb051a669c00dc55cdcd31bed2d" name="ad715ebb051a669c00dc55cdcd31bed2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad715ebb051a669c00dc55cdcd31bed2d">&#9670;&#160;</a></span>led()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * led </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pratt parser function for left denotation (infix/postfix parsing). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td><a class="el" href="structParser.html" title="Parser state holding token stream and current position.">Parser</a> pointer. </td></tr>
    <tr><td class="paramname">left</td><td>Left expression. </td></tr>
    <tr><td class="paramname">bp</td><td>Binding power. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Parsed expression node.</dd></dl>
<p>Pratt parser function for left denotation (infix/postfix parsing).</p>
<p>This is part of the Pratt parser implementation. The "led" function handles tokens that can appear after an expression has been parsed (binary operators and postfix operators).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">left</td><td>The left operand expression (already parsed) </td></tr>
    <tr><td class="paramname">bp</td><td>The current binding power context</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed expression AST node incorporating the left operand, or the original left expression if no valid LED is found</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Binary arithmetic and logical operators: +, -, *, /, ==, !=, etc.</li>
<li>Function calls: function(args)</li>
<li>Assignment: variable = value</li>
<li>Member access: object.member</li>
<li>Postfix operators: variable++, variable&ndash;</li>
<li>Array indexing: array[index]</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#a39ffb04f9526d5ee88fa488db078cbc1" title="Null Denotation - handles prefix expressions and primary expressions.">nud()</a>, <a class="el" href="parser_8h.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="parser_8h.html#aae76f2e2da0e519b78628915240200dd">binary()</a>, <a class="el" href="parser_8h.html#a77a8786dfb25898d7c4ffbc0ca8eafcf">call_expr()</a>, <a class="el" href="parser_8h.html#a683f4d2d2d297649d7b0d2d3dc3bad8e">assign_expr()</a>, <a class="el" href="parser_8h.html#a6ec4a015146e7598655f260ecb559a84">prefix_expr()</a> </dd></dl>

</div>
</div>
<a id="a116eace6cdf11c0f5a066af2e7c069b1" name="a116eace6cdf11c0f5a066af2e7c069b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116eace6cdf11c0f5a066af2e7c069b1">&#9670;&#160;</a></span>loop_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * loop_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses loop statements (infinite, while, or for loops) </p>
<p>Dispatcher function that determines the type of loop based on the following tokens and delegates to the appropriate specialized parser:</p>
<ul>
<li><code>loop { ... }</code> → infinite loop</li>
<li><code>loop [initializers](...) { ... }</code> → for loop <br  />
</li>
<li><code>loop (condition) { ... }</code> → while loop</li>
<li><code>loop (condition) : (optional_condition) { ... }</code> → while loop with secondary condition</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the appropriate loop statement AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The specific loop type is determined by the token following 'loop' </dd>
<dd>
All loop bodies must be block statements</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_2stmt_8c.html#a733ecd3287cefe3f8128a70d3db2e0fd" title="Parses an infinite loop statement.">infinite_loop_stmt()</a>, <a class="el" href="parser_2stmt_8c.html#a3453df19c4bcb4b00371410abf3962e0" title="Parses a for loop statement.">for_loop_stmt()</a>, <a class="el" href="parser_8c.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="parser_2stmt_8c.html#a398fc7e43b145f2332fbb0711e59b471" title="Parses a block statement.">block_stmt()</a>, <a class="el" href="ast_8h.html#a51dd617007d1bdca9777987287afc847">create_loop_stmt()</a> </dd></dl>

</div>
</div>
<a id="a23d6ab71810f245f89f55deefef54328" name="a23d6ab71810f245f89f55deefef54328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d6ab71810f245f89f55deefef54328">&#9670;&#160;</a></span>memcpy_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * memcpy_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39ffb04f9526d5ee88fa488db078cbc1" name="a39ffb04f9526d5ee88fa488db078cbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ffb04f9526d5ee88fa488db078cbc1">&#9670;&#160;</a></span>nud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * nud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Null Denotation - handles prefix expressions and primary expressions. </p>
<p>This is part of the Pratt parser implementation. The "nud" function handles tokens that can appear at the beginning of an expression (prefix operators and primary expressions like literals and identifiers).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed expression AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Primary expressions: numbers, strings, identifiers</li>
<li>Prefix unary operators: -, +, !, ++, &ndash;</li>
<li>Grouped expressions: (expression)</li>
<li>Array literals: [expression, ...]</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#ad715ebb051a669c00dc55cdcd31bed2d" title="Left Denotation - handles binary and postfix expressions.">led()</a>, <a class="el" href="parser_8c.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="parser_2expr_8c.html#a481c538e520948ab138a8c5b0a8324c6">primary()</a>, <a class="el" href="parser_2expr_8c.html#a517fa2b63adec675d032991a3a712572">unary()</a>, <a class="el" href="parser_2expr_8c.html#a1ecf965f76c333d977e1ffafbef4174e">grouping()</a>, <a class="el" href="parser_2expr_8c.html#ade768344c2d92f84219dfbddb9d37987">array_expr()</a> </dd></dl>

</div>
</div>
<a id="ab4f10f4ace5bea57b54d84c5088d349e" name="ab4f10f4ace5bea57b54d84c5088d349e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f10f4ace5bea57b54d84c5088d349e">&#9670;&#160;</a></span>p_advance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structToken.html">Token</a> p_advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>psr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advances to the next token and returns the current token. </p>
<p>This function moves the parser position forward by one token and returns the token that was current before advancing. This is the primary mechanism for consuming tokens during parsing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psr</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The token that was current before advancing, or EOF token if already at the end of the token stream</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The parser position is incremented only if there are tokens available </dd>
<dd>
Safe to call at end of stream - returns EOF token and doesn't advance </dd>
<dd>
This is a mutating operation that changes parser state</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>After calling this function, subsequent calls to <a class="el" href="parser__utils_8c.html#a7fbcabd9ce88ca44946533a7aaaa68a4" title="Gets the current token without advancing the parser position.">p_current()</a> will return the next token in the stream</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser__utils_8c.html#a7fbcabd9ce88ca44946533a7aaaa68a4" title="Gets the current token without advancing the parser position.">p_current()</a>, <a class="el" href="parser__utils_8c.html#ad438bd01c47ce6a0824f58f003cb81e5" title="Checks if there are more tokens available for parsing.">p_has_tokens()</a>, <a class="el" href="parser__utils_8c.html#a8ae2c122d273b1681a60ee873efe2a4f" title="Consumes a token of the expected type or reports an error.">p_consume()</a> </dd></dl>

</div>
</div>
<a id="a8ae2c122d273b1681a60ee873efe2a4f" name="a8ae2c122d273b1681a60ee873efe2a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae2c122d273b1681a60ee873efe2a4f">&#9670;&#160;</a></span>p_consume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structToken.html">Token</a> p_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>psr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921">TokenType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consumes a token of the expected type or reports an error. </p>
<p>This function is used when the parser expects a specific token type at the current position. If the current token matches the expected type, it advances and returns the token. If not, it reports a syntax error with the provided error message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psr</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">type</td><td>The expected token type that should be at the current position </td></tr>
    <tr><td class="paramname">error_msg</td><td>Error message to display if the token doesn't match</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The consumed token if it matches the expected type, or an EOF token if there's a mismatch (indicating an error)</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function combines token validation and consumption in one operation </dd>
<dd>
Error reporting includes current line, column, and token length information </dd>
<dd>
The parser position advances only on successful token match </dd>
<dd>
On error, the parser position remains unchanged</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Always check the return value's type if you need to handle parsing errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser__utils_8c.html#a7fbcabd9ce88ca44946533a7aaaa68a4" title="Gets the current token without advancing the parser position.">p_current()</a>, <a class="el" href="parser__utils_8c.html#ab4f10f4ace5bea57b54d84c5088d349e" title="Advances to the next token and returns the current token.">p_advance()</a>, <a class="el" href="parser_8c.html#a9a2a8ba5bea0c6ee41058bf6f8eb6178" title="Reports a parser error with detailed location information.">parser_error()</a>, <a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921" title="Enumeration of all possible token types recognized by the lexer.">TokenType</a> </dd></dl>

</div>
</div>
<a id="a7fbcabd9ce88ca44946533a7aaaa68a4" name="a7fbcabd9ce88ca44946533a7aaaa68a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fbcabd9ce88ca44946533a7aaaa68a4">&#9670;&#160;</a></span>p_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structToken.html">Token</a> p_current </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>psr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current token without advancing the parser position. </p>
<p>This function returns the token at the current parser position without modifying the parser state. It's the most frequently used function for examining the current token during parsing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psr</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current token, or an EOF token if at the end of the token stream</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is safe to call even when at the end of the token stream </dd>
<dd>
The returned token contains all token information: type, value, position, etc. </dd>
<dd>
Does not modify parser state - can be called multiple times safely</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser__utils_8c.html#ab4f10f4ace5bea57b54d84c5088d349e" title="Advances to the next token and returns the current token.">p_advance()</a>, <a class="el" href="parser__utils_8c.html#a12fe3f2a756479a093d29f08946c57d7" title="Peeks at a token at the specified offset from current position.">p_peek()</a>, <a class="el" href="structToken.html" title="Represents a single token extracted by the lexer.">Token</a> </dd></dl>

</div>
</div>
<a id="ad438bd01c47ce6a0824f58f003cb81e5" name="ad438bd01c47ce6a0824f58f003cb81e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad438bd01c47ce6a0824f58f003cb81e5">&#9670;&#160;</a></span>p_has_tokens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool p_has_tokens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>psr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if there are more tokens available for parsing. </p>
<p>This function determines whether the parser has reached the end of the token stream. It's used throughout the parser to control parsing loops and prevent buffer overruns when accessing tokens.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psr</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there are more tokens to process (and current token is not EOF), false if at end of stream or current token is EOF</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function performs two checks:<ol type="1">
<li>Position is within the token array bounds</li>
<li>Current token is not TOK_EOF (which marks end of input)</li>
</ol>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser__utils_8c.html#a7fbcabd9ce88ca44946533a7aaaa68a4" title="Gets the current token without advancing the parser position.">p_current()</a>, <a class="el" href="parser__utils_8c.html#ab4f10f4ace5bea57b54d84c5088d349e" title="Advances to the next token and returns the current token.">p_advance()</a> </dd></dl>

</div>
</div>
<a id="a12fe3f2a756479a093d29f08946c57d7" name="a12fe3f2a756479a093d29f08946c57d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fe3f2a756479a093d29f08946c57d7">&#9670;&#160;</a></span>p_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structToken.html">Token</a> p_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>psr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peeks at a token at the specified offset from current position. </p>
<p>This function allows looking ahead in the token stream without advancing the current position. It's useful for making parsing decisions based on upcoming tokens (lookahead parsing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psr</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">offset</td><td>Number of positions ahead to look (0 = current, 1 = next, etc.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structToken.html" title="Represents a single token extracted by the lexer.">Token</a> at the specified offset, or an EOF token if the offset goes beyond the end of the token stream</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Common usage patterns:<ul>
<li><code>p_peek(parser, 0)</code> is equivalent to <code>p_current(parser)</code></li>
<li><code>p_peek(parser, 1)</code> looks at the next token</li>
<li>Safe to use with any offset; returns EOF token for out-of-bounds access</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser__utils_8c.html#a7fbcabd9ce88ca44946533a7aaaa68a4" title="Gets the current token without advancing the parser position.">p_current()</a>, <a class="el" href="structToken.html" title="Represents a single token extracted by the lexer.">Token</a>, <a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921aee5e9bd304d0b8dba470b61e1643dcd8">TOK_EOF</a> </dd></dl>

</div>
</div>
<a id="a92a3429a7335866e6d3e6da546e7dbab" name="a92a3429a7335866e6d3e6da546e7dbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a3429a7335866e6d3e6da546e7dbab">&#9670;&#160;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structGrowableArray.html">GrowableArray</a> *&#160;</td>
          <td class="paramname"><em>tks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structArenaAllocator.html">ArenaAllocator</a> *&#160;</td>
          <td class="paramname"><em>arena</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a full program from tokens into an AST of statements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tks</td><td><a class="el" href="structGrowableArray.html" title="Growable array backed by an arena allocator.">GrowableArray</a> containing tokens. </td></tr>
    <tr><td class="paramname">arena</td><td>Memory arena for allocations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root AST statement node (program).</dd></dl>
<p>Parses a full program from tokens into an AST of statements.</p>
<p>This is the entry point for the parser. It takes a growable array of tokens and converts them into a complete program AST node containing all parsed statements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tks</td><td>Growable array containing all tokens from the lexer </td></tr>
    <tr><td class="paramname">arena</td><td>Arena allocator for memory management during parsing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the root AST node (Program node) containing all parsed statements, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function estimates the initial capacity for statements based on token count </dd>
<dd>
All memory allocations use the provided arena allocator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structParser.html" title="Parser state holding token stream and current position.">Parser</a>, <a class="el" href="parser_8h.html#aad4d5835f66e6e7e08a1358b18152665" title="Parses a single statement.">parse_stmt()</a>, <a class="el" href="ast_8h.html#a60c38b33bb0195508a6cd65fb541e226">create_program_node()</a> </dd></dl>

</div>
</div>
<a id="a2701baa126589d22ff03eb7ebbada5f5" name="a2701baa126589d22ff03eb7ebbada5f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2701baa126589d22ff03eb7ebbada5f5">&#9670;&#160;</a></span>parse_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * parse_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses an expression using the Pratt parsing algorithm. </p>
<p>This is the core expression parsing function that implements the Pratt parser algorithm. It handles operator precedence and associativity automatically through the binding power mechanism.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">bp</td><td>Minimum binding power - only operators with higher binding power will be consumed by this call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed expression AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm works by:<ol type="1">
<li>Getting the left expression using <a class="el" href="parser_8c.html#a39ffb04f9526d5ee88fa488db078cbc1" title="Null Denotation - handles prefix expressions and primary expressions.">nud()</a></li>
<li>While the next operator has higher binding power than bp:<ul>
<li>Use <a class="el" href="parser_8c.html#ad715ebb051a669c00dc55cdcd31bed2d" title="Left Denotation - handles binary and postfix expressions.">led()</a> to extend the expression with the operator</li>
</ul>
</li>
<li>Return the final expression</li>
</ol>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#a39ffb04f9526d5ee88fa488db078cbc1" title="Null Denotation - handles prefix expressions and primary expressions.">nud()</a>, <a class="el" href="parser_8c.html#ad715ebb051a669c00dc55cdcd31bed2d" title="Left Denotation - handles binary and postfix expressions.">led()</a>, <a class="el" href="parser_8c.html#abd32c60384ae40c357cc28e65fd764d1" title="Gets the binding power (precedence) for a given token type.">get_bp()</a>, <a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e" title="Binding power (precedence) levels for expression parsing.">BindingPower</a> </dd></dl>

</div>
</div>
<a id="a7e6e92eed019bfb4c14934d50c82acfe" name="a7e6e92eed019bfb4c14934d50c82acfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6e92eed019bfb4c14934d50c82acfe">&#9670;&#160;</a></span>parse_module_declaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * parse_module_declaration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad4d5835f66e6e7e08a1358b18152665" name="aad4d5835f66e6e7e08a1358b18152665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4d5835f66e6e7e08a1358b18152665">&#9670;&#160;</a></span>parse_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * parse_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a single statement. </p>
<p>This function dispatches to the appropriate statement parsing function based on the current token. It also handles visibility modifiers (public/private) that can appear before certain statement types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed statement AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Variable declarations: const, var</li>
<li>Control flow: return, if, loop, break, continue</li>
<li>Block statements: { ... }</li>
<li>Print statements: print, println</li>
<li>Expression statements: any expression followed by semicolon</li>
<li>Visibility modifiers: public, private (applied to declarations)</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#acd0470a765c07f4aa6855db5449e351a" title="Parses a constant declaration statement.">const_stmt()</a>, <a class="el" href="parser_8h.html#a74b60c0d077f19dca00679311b5ce1d9" title="Parses a variable declaration statement.">var_stmt()</a>, <a class="el" href="parser_8h.html#a65feab14f178a93af29954494842495c" title="Parses a return statement.">return_stmt()</a>, <a class="el" href="parser_8h.html#a398fc7e43b145f2332fbb0711e59b471" title="Parses a block statement.">block_stmt()</a>, <a class="el" href="parser_8h.html#a5a2c054597dd672f140bd9859e51da10" title="Parses if/elif/else conditional statements.">if_stmt()</a>, <a class="el" href="parser_8h.html#a116eace6cdf11c0f5a066af2e7c069b1" title="Parses loop statements (infinite, while, or for loops)">loop_stmt()</a>, <a class="el" href="parser_8h.html#a5dc127de3e1e39ab9270bd87fe3733a6" title="Parses print/println statements.">print_stmt()</a>, <a class="el" href="parser_8h.html#ab63fdeaaa163c06ed9af09d86379b060" title="Parses break and continue statements.">break_continue_stmt()</a>, <a class="el" href="parser_8h.html#a25a630a2b0ae343cd5bd2016c545a2ac" title="Parses an expression statement.">expr_stmt()</a> </dd></dl>

</div>
</div>
<a id="a16d4d98cf3fc80e10331bcd1d8b77e26" name="a16d4d98cf3fc80e10331bcd1d8b77e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d4d98cf3fc80e10331bcd1d8b77e26">&#9670;&#160;</a></span>parse_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> * parse_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a type annotation. </p>
<p>This function parses type expressions used in variable declarations, function parameters, return types, etc. It handles primitive types, pointer types, array types, and user-defined types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the parsed Type AST node, or NULL if parsing fails</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Handles:<ul>
<li>Primitive types: int, uint, float, bool, string, void, char</li>
<li>Pointer types: *type</li>
<li>Array types: [size]type or []type</li>
<li>User-defined types: identified by TOK_IDENTIFIER</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Prints error message to stderr for unexpected tokens</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8h.html#a4b598fef0adda01f89712c89e337c315">tnud()</a>, <a class="el" href="parser_8h.html#ac9cffb5ed1ef3cd27b0dbcd511044919">tled()</a>, <a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921" title="Enumeration of all possible token types recognized by the lexer.">TokenType</a> </dd></dl>

</div>
</div>
<a id="a9a2a8ba5bea0c6ee41058bf6f8eb6178" name="a9a2a8ba5bea0c6ee41058bf6f8eb6178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2a8ba5bea0c6ee41058bf6f8eb6178">&#9670;&#160;</a></span>parser_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parser_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>psr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>error_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tk_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report a parser error with detailed location info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psr</td><td>Pointer to the parser. </td></tr>
    <tr><td class="paramname">error_type</td><td>Type/category of the error. </td></tr>
    <tr><td class="paramname">file</td><td>Source file where error occurred. </td></tr>
    <tr><td class="paramname">msg</td><td>Error message. </td></tr>
    <tr><td class="paramname">line</td><td>Line number of error. </td></tr>
    <tr><td class="paramname">col</td><td>Column number of error. </td></tr>
    <tr><td class="paramname">tk_length</td><td>Length of the token causing the error.</td></tr>
  </table>
  </dd>
</dl>
<p>Report a parser error with detailed location info.</p>
<p>Creates and adds an error to the global error system with information about where the error occurred in the source code, including line and column information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psr</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">error_type</td><td>String describing the type of error (e.g., "SyntaxError") </td></tr>
    <tr><td class="paramname">file</td><td>Path to the source file where the error occurred </td></tr>
    <tr><td class="paramname">msg</td><td>Detailed error message describing what went wrong </td></tr>
    <tr><td class="paramname">line</td><td>Line number where the error occurred (1-based) </td></tr>
    <tr><td class="paramname">col</td><td>Column number where the error occurred (1-based) </td></tr>
    <tr><td class="paramname">tk_length</td><td>Length of the token that caused the error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function uses the arena allocator to duplicate the line text </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structErrorInformation.html" title="Stores detailed information about an error.">ErrorInformation</a>, <a class="el" href="error_8c.html#a4f3d659181bf27a69270daa8d5ab0658" title="Adds an error to the internal error list.">error_add()</a> </dd></dl>

</div>
</div>
<a id="a4710c0018883a69cd385b596a1cc5d0b" name="a4710c0018883a69cd385b596a1cc5d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4710c0018883a69cd385b596a1cc5d0b">&#9670;&#160;</a></span>pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> * pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ec4a015146e7598655f260ecb559a84" name="a6ec4a015146e7598655f260ecb559a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec4a015146e7598655f260ecb559a84">&#9670;&#160;</a></span>prefix_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * prefix_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a481c538e520948ab138a8c5b0a8324c6" name="a481c538e520948ab138a8c5b0a8324c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481c538e520948ab138a8c5b0a8324c6">&#9670;&#160;</a></span>primary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * primary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dc127de3e1e39ab9270bd87fe3733a6" name="a5dc127de3e1e39ab9270bd87fe3733a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc127de3e1e39ab9270bd87fe3733a6">&#9670;&#160;</a></span>print_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * print_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses print/println statements. </p>
<p>Handles output statements with the syntax:</p><ul>
<li><code>print(expr1, expr2, ...);</code></li>
<li><code>println(expr1, expr2, ...);</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">ln</td><td>Whether this is a println (true) or print (false) statement</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the print statement AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Supports multiple expressions separated by commas </dd>
<dd>
println automatically adds a newline after output </dd>
<dd>
Empty argument lists are allowed: <code>print();</code> </dd>
<dd>
All expressions are evaluated and their values are printed</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="ast_8h.html#a2ad8995fdc7934f9a74a094ab9c9aee5">create_print_stmt()</a> </dd></dl>

</div>
</div>
<a id="a65feab14f178a93af29954494842495c" name="a65feab14f178a93af29954494842495c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65feab14f178a93af29954494842495c">&#9670;&#160;</a></span>return_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * return_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a return statement. </p>
<p>Handles return statements with optional return values:</p><ul>
<li><code>return;</code> - Return with no value (void return)</li>
<li><code>return expression;</code> - Return with a value</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the return statement AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The return value is optional; if not present, creates a void return </dd>
<dd>
Requires a semicolon terminator</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="ast_8h.html#a764e77cfafaf89f6b6332e9818906749">create_return_stmt()</a> </dd></dl>

</div>
</div>
<a id="ac7b72b6b4d03c16bc1c17d7eaa62b5fc" name="ac7b72b6b4d03c16bc1c17d7eaa62b5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b72b6b4d03c16bc1c17d7eaa62b5fc">&#9670;&#160;</a></span>sizeof_expr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * sizeof_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b1d180c582c2a00245cc9c146764c16" name="a0b1d180c582c2a00245cc9c146764c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1d180c582c2a00245cc9c146764c16">&#9670;&#160;</a></span>struct_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * struct_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_public</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a structure declaration statement. </p>
<p>Handles struct declarations with public/private member visibility: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>{</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    field1: Type1,</div>
<div class="line">    method1 = fn() <a class="code hl_struct" href="structAstNode.html">Type</a> { ... }</div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    field2: Type2,</div>
<div class="line">};</div>
<div class="ttc" id="astructAstNode_html"><div class="ttname"><a href="structAstNode.html">AstNode</a></div><div class="ttdef"><b>Definition</b> ast.h:120</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">name</td><td>Struct name (already parsed by caller) </td></tr>
    <tr><td class="paramname">is_public</td><td>Whether this struct has public visibility</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the struct declaration AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Members are separated into public and private arrays </dd>
<dd>
Supports both data fields (name: Type) and methods (name = fn ...) </dd>
<dd>
Visibility defaults to public unless explicitly changed </dd>
<dd>
Visibility changes affect all subsequent members until changed again</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_2stmt_8c.html#a1d805e55bb21e6bc022ed7a418445cbe" title="Parses a function declaration statement.">fn_stmt()</a>, <a class="el" href="ast_8h.html#a84db041dc07a72b792eca01dd457dbf2">create_field_decl_stmt()</a>, <a class="el" href="ast_8h.html#ad98975f9f8c56eda7704eb4b3d13997a">create_struct_decl_stmt()</a> </dd></dl>

</div>
</div>
<a id="ac6127fb2a8cfbdfe0e3264ac97bfe75e" name="ac6127fb2a8cfbdfe0e3264ac97bfe75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6127fb2a8cfbdfe0e3264ac97bfe75e">&#9670;&#160;</a></span>tget_bp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a> tget_bp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lexer_8h.html#aa520fbf142ba1e7e659590c07da31921">TokenType</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9cffb5ed1ef3cd27b0dbcd511044919" name="ac9cffb5ed1ef3cd27b0dbcd511044919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9cffb5ed1ef3cd27b0dbcd511044919">&#9670;&#160;</a></span>tled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> * tled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#afda66df955be06c6d47c751fc63ebc0e">BindingPower</a>&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b598fef0adda01f89712c89e337c315" name="a4b598fef0adda01f89712c89e337c315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b598fef0adda01f89712c89e337c315">&#9670;&#160;</a></span>tnud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#ab4c2d65407b5483fbc6d02144073c2f3">Type</a> * tnud </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a517fa2b63adec675d032991a3a712572" name="a517fa2b63adec675d032991a3a712572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a517fa2b63adec675d032991a3a712572">&#9670;&#160;</a></span>unary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a9392eba3b24c6cb6afff1173735ac359">Expr</a> * unary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dad6cf3360477655b7a6f8667b8ab78" name="a9dad6cf3360477655b7a6f8667b8ab78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dad6cf3360477655b7a6f8667b8ab78">&#9670;&#160;</a></span>use_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * use_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74b60c0d077f19dca00679311b5ce1d9" name="a74b60c0d077f19dca00679311b5ce1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b60c0d077f19dca00679311b5ce1d9">&#9670;&#160;</a></span>var_stmt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ast_8h.html#a04c02a467e5a9ad042686282af900150">Stmt</a> * var_stmt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParser.html">Parser</a> *&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_public</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a variable declaration statement. </p>
<p>Handles variable declarations with the syntax: <code>var name: Type = value;</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parser</td><td>Pointer to the parser instance </td></tr>
    <tr><td class="paramname">is_public</td><td>Whether this variable has public visibility</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the variable declaration AST node, or NULL on failure</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Variables are mutable by default (unlike constants) </dd>
<dd>
Type annotation is required </dd>
<dd>
Initial value assignment is required </dd>
<dd>
Creates a variable declaration with is_mutable set to true</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="parser_8c.html#a16d4d98cf3fc80e10331bcd1d8b77e26" title="Parses a type annotation.">parse_type()</a>, <a class="el" href="parser_8c.html#a2701baa126589d22ff03eb7ebbada5f5" title="Parses an expression using the Pratt parsing algorithm.">parse_expr()</a>, <a class="el" href="ast_8h.html#a4cda058317dc36ea7f21ddb85a0bd142">create_var_decl_stmt()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
